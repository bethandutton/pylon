/**
 * Figma Variable Script Generator
 *
 * Reads tokens.json and generates Figma Plugin API scripts that create
 * variable collections in Figma. These scripts are executed via Figma Console MCP.
 *
 * IMPORTANT Figma API requirements (2025+):
 * - createVariable() takes collection OBJECT, not collection.id
 * - Use setVariableCodeSyntax("WEB", value), NOT .codeSyntax = { WEB: value }
 * - Use console.log() for output, NOT figma.notify() or return values
 * - NEVER call figma.closePlugin() — it kills the Desktop Bridge connection
 * - Top-level await works — no IIFE wrapper needed
 * - Fill colors use { r, g, b } only — no 'a' property
 *
 * Output:
 *   figma-scripts/01-create-color-variables.js
 *   figma-scripts/02-create-typography-variables.js
 *   figma-scripts/03-create-spacing-variables.js
 *   figma-scripts/04-create-radii-variables.js
 */

import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { resolve } from 'path';

const TOKENS_PATH = resolve(__dirname, '../tokens.json');
const OUTPUT_DIR = resolve(__dirname, '../figma-scripts');

interface Tokens {
  colors: {
    light: Record<string, string>;
    dark: Record<string, string>;
  };
  typography: {
    fontFamilies: { base: string; mono: string };
    styles: Record<string, {
      fontSize: number;
      fontWeight: number;
      lineHeight: number;
      letterSpacing: number;
    }>;
  };
  spacing: Record<string, number>;
  radii: Record<string, number>;
  shadows: {
    light: Record<string, string>;
    dark: Record<string, string>;
  };
  transitions: Record<string, string>;
}

const tokens: Tokens = JSON.parse(readFileSync(TOKENS_PATH, 'utf-8'));
mkdirSync(OUTPUT_DIR, { recursive: true });

// ─── 01: Color Variables ───────────────────────────────────────────

function generateColorScript(): string {
  const lightColors = tokens.colors.light;
  const darkColors = tokens.colors.dark;

  const lines: string[] = [
    '// Pylon Color Variables — Generated by figma-sync',
    '// Execute via Figma Console MCP (figma_execute)',
    '// API fixes: collection object (not ID), setVariableCodeSyntax() method',
    '',
    'const collections = await figma.variables.getLocalVariableCollectionsAsync();',
    'let collection = collections.find(c => c.name === "Pylon/Colors");',
    'if (!collection) {',
    '  collection = figma.variables.createVariableCollection("Pylon/Colors");',
    '}',
    '',
    '// Set up Light and Dark modes',
    'const modes = collection.modes;',
    'let lightModeId = modes[0].modeId;',
    'collection.renameMode(lightModeId, "Light");',
    '',
    'let darkModeId;',
    'if (modes.length > 1) {',
    '  darkModeId = modes[1].modeId;',
    '  collection.renameMode(darkModeId, "Dark");',
    '} else {',
    '  darkModeId = collection.addMode("Dark");',
    '}',
    '',
    'function hexToRgba(hex) {',
    '  hex = hex.replace("#", "");',
    '  return {',
    '    r: parseInt(hex.slice(0, 2), 16) / 255,',
    '    g: parseInt(hex.slice(2, 4), 16) / 255,',
    '    b: parseInt(hex.slice(4, 6), 16) / 255',
    '  };',
    '}',
    '',
    'async function upsertColor(name, lightHex, darkHex) {',
    '  const existing = (await figma.variables.getLocalVariablesAsync("COLOR"))',
    '    .find(v => v.name === name && v.variableCollectionId === collection.id);',
    '  const variable = existing || figma.variables.createVariable(name, collection, "COLOR");',
    '',
    '  variable.setValueForMode(lightModeId, hexToRgba(lightHex));',
    '  variable.setValueForMode(darkModeId, hexToRgba(darkHex));',
    '  variable.scopes = ["ALL_FILLS", "STROKE_COLOR"];',
    '  variable.setVariableCodeSyntax("WEB", "--pylon-" + name.replace(/\\//g, "-"));',
    '}',
    '',
  ];

  for (const [name, lightHex] of Object.entries(lightColors)) {
    const darkHex = darkColors[name] || lightHex;
    lines.push(`await upsertColor("${name}", "${lightHex}", "${darkHex}");`);
  }

  lines.push('');
  lines.push('const count = (await figma.variables.getLocalVariablesAsync("COLOR"))');
  lines.push('  .filter(v => v.variableCollectionId === collection.id).length;');
  lines.push('console.log("\\u2713 Pylon colors synced: " + count + " variables (Light + Dark modes)");');

  return lines.join('\n');
}

// ─── 02: Typography Variables ──────────────────────────────────────

function generateTypographyScript(): string {
  const styles = tokens.typography.styles;

  const lines: string[] = [
    '// Pylon Typography Variables — Generated by figma-sync',
    '// Execute via Figma Console MCP (figma_execute)',
    '',
    'const collections = await figma.variables.getLocalVariableCollectionsAsync();',
    'let collection = collections.find(c => c.name === "Pylon/Typography");',
    'if (!collection) {',
    '  collection = figma.variables.createVariableCollection("Pylon/Typography");',
    '}',
    'const modeId = collection.modes[0].modeId;',
    '',
    'async function upsertFloat(name, value, scope) {',
    '  const existing = (await figma.variables.getLocalVariablesAsync("FLOAT"))',
    '    .find(v => v.name === name && v.variableCollectionId === collection.id);',
    '  const variable = existing || figma.variables.createVariable(name, collection, "FLOAT");',
    '  variable.setValueForMode(modeId, value);',
    '  variable.scopes = [scope];',
    '}',
    '',
    '// Line-height values are in px (fontSize * lineHeightRatio)',
    'const styles = [',
  ];

  // Build the styles array with line-height computed as px
  const styleEntries = Object.entries(styles);
  for (let i = 0; i < styleEntries.length; i++) {
    const [styleName, style] = styleEntries[i];
    // Line-height: convert ratio to px (e.g. fontSize 48 * ratio 1.15 = 55.2px)
    const lineHeightPx = Math.round(style.fontSize * style.lineHeight * 10) / 10;
    const comma = i < styleEntries.length - 1 ? ',' : '';
    lines.push(`  ["${styleName}", ${style.fontSize}, ${style.fontWeight}, ${lineHeightPx}, ${style.letterSpacing}]${comma}`);
  }

  lines.push('];');
  lines.push('');
  lines.push('for (const [name, size, weight, lh, ls] of styles) {');
  lines.push('  await upsertFloat("font-size/" + name, size, "FONT_SIZE");');
  lines.push('  await upsertFloat("font-weight/" + name, weight, "FONT_WEIGHT");');
  lines.push('  await upsertFloat("line-height/" + name, lh, "LINE_HEIGHT");');
  lines.push('  await upsertFloat("letter-spacing/" + name, ls, "LETTER_SPACING");');
  lines.push('}');
  lines.push('');
  lines.push('const count = (await figma.variables.getLocalVariablesAsync("FLOAT"))');
  lines.push('  .filter(v => v.variableCollectionId === collection.id).length;');
  lines.push('console.log("\\u2713 Pylon typography synced: " + count + " variables");');

  return lines.join('\n');
}

// ─── 03: Spacing Variables ─────────────────────────────────────────

function generateSpacingScript(): string {
  const spacing = tokens.spacing;

  const lines: string[] = [
    '// Pylon Spacing Variables — Generated by figma-sync',
    '// Execute via Figma Console MCP (figma_execute)',
    '',
    'const collections = await figma.variables.getLocalVariableCollectionsAsync();',
    'let collection = collections.find(c => c.name === "Pylon/Spacing");',
    'if (!collection) {',
    '  collection = figma.variables.createVariableCollection("Pylon/Spacing");',
    '}',
    'const modeId = collection.modes[0].modeId;',
    '',
    'async function upsertFloat(name, value) {',
    '  const existing = (await figma.variables.getLocalVariablesAsync("FLOAT"))',
    '    .find(v => v.name === name && v.variableCollectionId === collection.id);',
    '  const variable = existing || figma.variables.createVariable(name, collection, "FLOAT");',
    '  variable.setValueForMode(modeId, value);',
    '  variable.scopes = ["GAP", "WIDTH_HEIGHT"];',
    '  variable.setVariableCodeSyntax("WEB", "var(--pylon-space) * " + (value / 4));',
    '}',
    '',
  ];

  for (const [key, value] of Object.entries(spacing)) {
    lines.push(`await upsertFloat("space/${key}", ${value});`);
  }

  lines.push('');
  lines.push('const count = (await figma.variables.getLocalVariablesAsync("FLOAT"))');
  lines.push('  .filter(v => v.variableCollectionId === collection.id).length;');
  lines.push('console.log("\\u2713 Pylon spacing synced: " + count + " variables");');

  return lines.join('\n');
}

// ─── 04: Radii Variables ───────────────────────────────────────────

function generateRadiiScript(): string {
  const radii = tokens.radii;

  const lines: string[] = [
    '// Pylon Radii Variables — Generated by figma-sync',
    '// Execute via Figma Console MCP (figma_execute)',
    '',
    'const collections = await figma.variables.getLocalVariableCollectionsAsync();',
    'let collection = collections.find(c => c.name === "Pylon/Radii");',
    'if (!collection) {',
    '  collection = figma.variables.createVariableCollection("Pylon/Radii");',
    '}',
    'const modeId = collection.modes[0].modeId;',
    '',
    'async function upsertFloat(name, value) {',
    '  const existing = (await figma.variables.getLocalVariablesAsync("FLOAT"))',
    '    .find(v => v.name === name && v.variableCollectionId === collection.id);',
    '  const variable = existing || figma.variables.createVariable(name, collection, "FLOAT");',
    '  variable.setValueForMode(modeId, value);',
    '  variable.scopes = ["CORNER_RADIUS"];',
    '  variable.setVariableCodeSyntax("WEB", "--pylon-radius-" + name.split("/")[1]);',
    '}',
    '',
  ];

  for (const [key, value] of Object.entries(radii)) {
    lines.push(`await upsertFloat("radius/${key}", ${value});`);
  }

  lines.push('');
  lines.push('const count = (await figma.variables.getLocalVariablesAsync("FLOAT"))');
  lines.push('  .filter(v => v.variableCollectionId === collection.id).length;');
  lines.push('console.log("\\u2713 Pylon radii synced: " + count + " variables");');

  return lines.join('\n');
}

// ─── Write all scripts ─────────────────────────────────────────────

const scripts = [
  { name: '01-create-color-variables.js', generate: generateColorScript },
  { name: '02-create-typography-variables.js', generate: generateTypographyScript },
  { name: '03-create-spacing-variables.js', generate: generateSpacingScript },
  { name: '04-create-radii-variables.js', generate: generateRadiiScript },
];

for (const { name, generate } of scripts) {
  const content = generate();
  const outPath = resolve(OUTPUT_DIR, name);
  writeFileSync(outPath, content + '\n');
  console.log(`Generated ${name}`);
}

console.log(`\nAll ${scripts.length} Figma variable scripts generated in figma-scripts/`);
