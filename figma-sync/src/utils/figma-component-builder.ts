/**
 * Figma Component Builder — Templates for Figma Plugin API code generation.
 *
 * Generates JavaScript code strings that create Figma components with
 * auto layout, variable bindings, text nodes, and variant properties.
 */

import type { ComponentSpec, VariantSpec, SizeSpec } from './component-parser.js';

/** Map Pylon token names to Figma variable paths. */
function tokenToVarPath(token: string): string {
  // e.g. "color-brand" → "color-brand" (matches the variable name in Pylon/Colors collection)
  return token;
}

/** Generate code to look up a Figma variable by name. */
function lookupVariable(varName: string, collection: string): string {
  return `(await figma.variables.getLocalVariablesAsync("COLOR")).find(v => v.name === "${varName}" && v.variableCollectionId === colorCollectionId)`;
}

/** Generate the auto layout setup code for a component. */
export function generateAutoLayout(spec: ComponentSpec): string {
  const lines: string[] = [];

  if (spec.layout.display === 'inline-flex' || spec.layout.display === 'flex') {
    lines.push(`    node.layoutMode = "${spec.layout.flexDirection === 'column' ? 'VERTICAL' : 'HORIZONTAL'}";`);

    if (spec.layout.alignItems === 'center') {
      lines.push(`    node.counterAxisAlignItems = "CENTER";`);
    } else if (spec.layout.alignItems === 'stretch') {
      lines.push(`    node.counterAxisAlignItems = "STRETCH";`);
    }

    if (spec.layout.justifyContent === 'center') {
      lines.push(`    node.primaryAxisAlignItems = "CENTER";`);
    } else if (spec.layout.justifyContent === 'space-between') {
      lines.push(`    node.primaryAxisAlignItems = "SPACE_BETWEEN";`);
    }

    if (spec.layout.gap !== null) {
      lines.push(`    node.itemSpacing = ${spec.layout.gap};`);
    }
  }

  return lines.join('\n');
}

/** State display names for Figma variant properties. */
const STATE_DISPLAY: Record<string, string> = {
  default: 'Default',
  hovered: 'Hover',
  pressed: 'Pressed',
  disabled: 'Disabled',
  'focus-visible': 'Focused',
  focused: 'Focused',
  selected: 'Selected',
  invalid: 'Invalid',
  open: 'Open',
  indeterminate: 'Indeterminate',
  entering: 'Entering',
  exiting: 'Exiting',
};

export function stateDisplayName(state: string): string {
  return STATE_DISPLAY[state] || state.charAt(0).toUpperCase() + state.slice(1);
}

/**
 * Generate a full Figma Plugin API script for a component.
 * Creates all variant combinations as individual components, then combines them.
 */
export function generateComponentScript(spec: ComponentSpec): string {
  const lines: string[] = [];

  lines.push(`// ${spec.name} — Figma Component — Generated by figma-sync`);
  lines.push('// Execute via Figma Console MCP with the target file open');
  lines.push('');
  lines.push('(async () => {');

  // Find the color collection ID for variable binding
  lines.push('  const collections = await figma.variables.getLocalVariableCollectionsAsync();');
  lines.push('  const colorCollection = collections.find(c => c.name === "Pylon/Colors");');
  lines.push('  const colorCollectionId = colorCollection ? colorCollection.id : null;');
  lines.push('  const radiiCollection = collections.find(c => c.name === "Pylon/Radii");');
  lines.push('');
  lines.push('  // Helper: find a variable by name and collection');
  lines.push('  async function findColorVar(name) {');
  lines.push('    if (!colorCollectionId) return null;');
  lines.push('    const vars = await figma.variables.getLocalVariablesAsync("COLOR");');
  lines.push('    return vars.find(v => v.name === name && v.variableCollectionId === colorCollectionId) || null;');
  lines.push('  }');
  lines.push('');
  lines.push('  async function findFloatVar(name, collectionId) {');
  lines.push('    if (!collectionId) return null;');
  lines.push('    const vars = await figma.variables.getLocalVariablesAsync("FLOAT");');
  lines.push('    return vars.find(v => v.name === name && v.variableCollectionId === collectionId) || null;');
  lines.push('  }');
  lines.push('');
  lines.push('  // Load font before creating text');
  lines.push('  await figma.loadFontAsync({ family: "Inter", style: "Regular" });');
  lines.push('  await figma.loadFontAsync({ family: "Inter", style: "Medium" });');
  lines.push('  await figma.loadFontAsync({ family: "Inter", style: "Semi Bold" });');
  lines.push('  await figma.loadFontAsync({ family: "Inter", style: "Bold" });');
  lines.push('');
  lines.push('  const components = [];');
  lines.push('');

  // Determine variant combinations
  const hasVariants = spec.variants.length > 0;
  const hasSizes = spec.sizes.length > 0;
  const hasStates = spec.states.length > 1; // more than just "default"

  const variants = hasVariants ? spec.variants : [{ name: 'default', class: '', fill: null, textColor: null, stroke: null }];
  const sizes = hasSizes ? spec.sizes : [null];
  const states = spec.states;

  // Generate each combination
  for (const variant of variants) {
    for (const size of sizes) {
      for (const state of states) {
        const variantProps: string[] = [];
        if (hasVariants) variantProps.push(`Type=${variant.name.charAt(0).toUpperCase() + variant.name.slice(1)}`);
        if (hasSizes) variantProps.push(`Size=${size!.name.toUpperCase()}`);
        if (hasStates) variantProps.push(`State=${stateDisplayName(state)}`);

        const propString = variantProps.join(', ');
        const varName = `c_${variant.name}_${size?.name || 'default'}_${state}`.replace(/-/g, '_');

        lines.push(`  // ${propString}`);
        lines.push(`  {`);
        lines.push(`    const node = figma.createComponent();`);
        lines.push(`    node.name = "${propString}";`);

        // Auto layout
        if (spec.layout.display === 'inline-flex' || spec.layout.display === 'flex') {
          lines.push(`    node.layoutMode = "${spec.layout.flexDirection === 'column' ? 'VERTICAL' : 'HORIZONTAL'}";`);
          lines.push(`    node.primaryAxisSizingMode = "AUTO";`);
          lines.push(`    node.counterAxisSizingMode = "AUTO";`);

          if (spec.layout.alignItems === 'center') {
            lines.push(`    node.counterAxisAlignItems = "CENTER";`);
          }
          if (spec.layout.justifyContent === 'center') {
            lines.push(`    node.primaryAxisAlignItems = "CENTER";`);
          } else if (spec.layout.justifyContent === 'space-between') {
            lines.push(`    node.primaryAxisAlignItems = "SPACE_BETWEEN";`);
          }
          if (spec.layout.gap !== null) {
            lines.push(`    node.itemSpacing = ${spec.layout.gap};`);
          }
        }

        // Size (fixed height, auto width with padding)
        if (size) {
          if (size.height) {
            lines.push(`    node.counterAxisSizingMode = "FIXED";`);
            lines.push(`    node.resize(node.width, ${size.height});`);
          }
          if (size.paddingV !== null) {
            lines.push(`    node.paddingTop = ${size.paddingV};`);
            lines.push(`    node.paddingBottom = ${size.paddingV};`);
          }
          if (size.paddingH !== null) {
            lines.push(`    node.paddingLeft = ${size.paddingH};`);
            lines.push(`    node.paddingRight = ${size.paddingH};`);
          }
        }

        // Corner radius — bind to variable if possible
        if (spec.cornerRadius) {
          const radiusKey = spec.cornerRadius.replace('radius-', '');
          lines.push(`    const radiusVar = await findFloatVar("radius/${radiusKey}", radiiCollection?.id);`);
          lines.push(`    if (radiusVar) {`);
          lines.push(`      node.setBoundVariable("topLeftRadius", radiusVar);`);
          lines.push(`      node.setBoundVariable("topRightRadius", radiusVar);`);
          lines.push(`      node.setBoundVariable("bottomLeftRadius", radiusVar);`);
          lines.push(`      node.setBoundVariable("bottomRightRadius", radiusVar);`);
          lines.push(`    }`);
        }

        // Fill — bind to color variable
        if (variant.fill && variant.fill !== 'transparent') {
          lines.push(`    const fillVar = await findColorVar("${tokenToVarPath(variant.fill)}");`);
          lines.push(`    if (fillVar) {`);
          lines.push(`      const fillPaint = figma.variables.setBoundVariableForPaint({ type: "SOLID", color: {r:0,g:0,b:0} }, "color", fillVar);`);
          lines.push(`      node.fills = [fillPaint];`);
          lines.push(`    }`);
        } else if (variant.fill === 'transparent') {
          lines.push(`    node.fills = [];`);
        }

        // Stroke — bind to color variable
        if (variant.stroke && variant.stroke !== 'transparent') {
          lines.push(`    const strokeVar = await findColorVar("${tokenToVarPath(variant.stroke)}");`);
          lines.push(`    if (strokeVar) {`);
          lines.push(`      const strokePaint = figma.variables.setBoundVariableForPaint({ type: "SOLID", color: {r:0,g:0,b:0} }, "color", strokeVar);`);
          lines.push(`      node.strokes = [strokePaint];`);
          lines.push(`      node.strokeWeight = 1;`);
          lines.push(`    }`);
        }

        // Add a text node (label)
        const fontWeight = getFontWeightForTextStyle(size?.textStyle || spec.textStyle);
        const fontSize = getFontSizeForTextStyle(size?.textStyle || spec.textStyle);
        lines.push(`    const text = figma.createText();`);
        lines.push(`    text.fontName = { family: "Inter", style: "${fontWeight}" };`);
        if (fontSize) {
          lines.push(`    text.fontSize = ${fontSize};`);
        }
        lines.push(`    text.characters = "${spec.name}";`);

        // Text color — bind to variable
        if (variant.textColor) {
          lines.push(`    const textVar = await findColorVar("${tokenToVarPath(variant.textColor)}");`);
          lines.push(`    if (textVar) {`);
          lines.push(`      const textPaint = figma.variables.setBoundVariableForPaint({ type: "SOLID", color: {r:0,g:0,b:0} }, "color", textVar);`);
          lines.push(`      text.fills = [textPaint];`);
          lines.push(`    }`);
        }
        lines.push(`    node.appendChild(text);`);

        // State-specific modifications
        if (state === 'disabled') {
          lines.push(`    node.opacity = 0.5;`);
        }
        if (state === 'focus-visible' || state === 'focused') {
          lines.push(`    // Focus ring effect`);
          lines.push(`    node.effects = [{`);
          lines.push(`      type: "DROP_SHADOW",`);
          lines.push(`      color: { r: 0.42, g: 0.545, b: 0.643, a: 1 },`);
          lines.push(`      offset: { x: 0, y: 0 },`);
          lines.push(`      radius: 0,`);
          lines.push(`      spread: 4,`);
          lines.push(`      visible: true,`);
          lines.push(`      blendMode: "NORMAL"`);
          lines.push(`    }];`);
        }

        lines.push(`    components.push(node);`);
        lines.push(`  }`);
        lines.push('');
      }
    }
  }

  // Combine into component set
  lines.push('  if (components.length > 1) {');
  lines.push(`    const componentSet = figma.combineAsVariants(components, figma.currentPage);`);
  lines.push(`    componentSet.name = "${spec.name}";`);
  lines.push('');
  lines.push('    // Auto-layout the component set for organization');
  lines.push('    componentSet.layoutMode = "HORIZONTAL";');
  lines.push('    componentSet.layoutWrap = "WRAP";');
  lines.push('    componentSet.itemSpacing = 24;');
  lines.push('    componentSet.counterAxisSpacing = 24;');
  lines.push('    componentSet.paddingTop = 40;');
  lines.push('    componentSet.paddingBottom = 40;');
  lines.push('    componentSet.paddingLeft = 40;');
  lines.push('    componentSet.paddingRight = 40;');
  lines.push('    componentSet.primaryAxisSizingMode = "AUTO";');
  lines.push('    componentSet.counterAxisSizingMode = "AUTO";');
  lines.push('  } else if (components.length === 1) {');
  lines.push(`    components[0].name = "${spec.name}";`);
  lines.push('  }');
  lines.push('');

  const totalVariants = variants.length * sizes.length * states.length;
  lines.push(`  figma.notify("✓ ${spec.name}: ${totalVariants} variants created");`);
  lines.push('  figma.closePlugin();');
  lines.push('})();');

  return lines.join('\n');
}

/** Map text style to Inter font style. */
function getFontWeightForTextStyle(style: string | null): string {
  if (!style) return 'Regular';
  // Map Pylon font weights to Inter font styles
  const weightMap: Record<string, string> = {
    'display-1': 'Bold',
    'display-2': 'Bold',
    'h1': 'Bold',
    'h2': 'Semi Bold',
    'h3': 'Semi Bold',
    'h4': 'Semi Bold',
    'h5': 'Semi Bold',
    'h6': 'Semi Bold',
    'body-lg': 'Regular',
    'body': 'Regular',
    'body-sm': 'Regular',
    'caption': 'Medium',
    'overline': 'Semi Bold',
    'label': 'Semi Bold',
    'small': 'Regular',
  };
  return weightMap[style] || 'Regular';
}

/** Map text style to font size in px. */
function getFontSizeForTextStyle(style: string | null): number | null {
  if (!style) return null;
  const sizeMap: Record<string, number> = {
    'display-1': 48,
    'display-2': 40,
    'h1': 32,
    'h2': 28,
    'h3': 24,
    'h4': 20,
    'h5': 18,
    'h6': 16,
    'body-lg': 17,
    'body': 15,
    'body-sm': 13,
    'caption': 12,
    'overline': 11,
    'label': 13,
    'small': 11,
  };
  return sizeMap[style] || null;
}
